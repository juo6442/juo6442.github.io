---
layout: post
title: "「새로 입사한 개발자가 프로젝트에 기여하는 방법 한 가지」를 읽고 한 공부"
categories: study
published: true
---

## 들어가며

김종립님이 마켓컬리 기술 블로그에 작성하신 [새로 입사한 개발자가 프로젝트에 기여하는 방법 한 가지](https://helloworld.kurly.com/blog/fix-style-with-command/)를 읽었습니다. '이런 쉽고 멋진 방법이!'라고 생각했습니다만, 부끄럽게도 중간중간에 나오는 셸 명령어 중에 모르는 것이 많더군요. 지금 일하는 곳에선 셸을 쓸 일보다는 주로 VS Code나 OpenGrok를 이용해 코드를 뚫어지게 들어다보는 시간이 많았거든요. 하지만 저도 셸을 아예 사용하지 않는 것은 아니고, 아는 게 많아지면 더 멋진 것을 할 수 있지 않을까요? 이런 이유로 복습과 학습을 위하여 부족하게나마 김종립님의 글에서 다룬 명령어에 대하여 조사해 보았습니다.

이하 소제목과 명령어는 김종립님의 글에서 가져온 것입니다.

## 코딩 스타일 가이드를 읽다가 작성한 Pull Request

```shell
find . -name '*.java' \
  | xargs egrep '^\s*if[^\{]*\s*$' --no-filename
```

- `find`: 현재 디렉토리와 그 하위에서 `*.java`를 검색합니다.
- `xargs`: 파이프로 연결되었으니 `find`의 출력이 `egrep`의 마지막 인자로 들어가도록 합니다.
- `egrep`: `grep -extended-regexp` 또는 `grep -E`와 동일하며, 확장 정규식을 지원합니다. 인자로 주어진 정규식과 매칭되는 부분을 파일에서 찾아 출력할 것입니다.
 - `'^\s*if[^\{]*\s*$'`
  - `^`: 문자열의 시작
  - `\s*`: 공백 0자 이상
  - `if`: `if`
  - `[^\{]*`: `{`가 아닌 문자 0자 이상
  - `\s*`: 공백 0자 이상. 바로 위에서 매칭되므로 없어도 될 거라 생각합니다.
  - `$`: 문자열의 끝
 - `--no-filename`: `grep`은 기본적으로 한 개 이상의 파일이 주어지면 `--with-filename`가 적용된 것과 같이 파일 이름을 출력하는데요, 이를 보이지 않게 한 것입니다.

## if, for 문에 붙은 괄호에 공백을 주자

```shell
KEYWORDS="(if|for|while|try)"
ag "$KEYWORDS\(" -l \
  | xargs sed -i ''  -E "s/$KEYWORDS\(/\1 (/"
```

- `"(if|for|while|try)"`: `if`, `for`, `while`, `try` 중 한 단어와 매칭되도록 합니다. 괄호로 묶었으니 그룹으로 지정되겠죠.
- ag: [the_silver_searcher](https://github.com/ggreer/the_silver_searcher), 코드 검색을 위한 툴로 빠를 뿐 아니라 여러 편리한 옵션이 있습니다.
 - `"$KEYWORDS\("`: `KEYWORDS`와 `(`가 붙어 있는 경우를 매칭합니다.
 - `-l`: 검색된 내용은 제외하고 파일명만 출력하도록 합니다.
- `sed`: Stream editor. 파일을 한 줄 한 줄 읽어서 대치 등의 명령을 수행할 수 있습니다.
 - `-i ''`: 수정 결과를 표준 출력으로 내보내지 않고 파일을 직접 수정합니다. Suffix가 빈 칸으로 주어져 백업은 생성하지 않습니다. 제 환경에서는 `-i''`와 같이 붙여야 동작했습니다.
 - `-E`: 확장 정규식을 사용할 수 있게 됩니다.
 - `"s/$KEYWORDS\(/\1 (/"`: `s/패턴1/패턴2/`와 같이 사용하면 패턴1을 2로 대치합니다. `/`를 기준으로 아래와 같이 나눠볼 수 있겠네요.
  - `s`: Substitute 명령
  - `$KEYWORDS\(`: 패턴1입니다. 내용은 위에서 설명했으니 생략합니다.
  - `\1 (`: 패턴2입니다. `\1`은 그룹1, 즉 `$KEYWORDS`를 말하며 이와 `(` 사이에 공백을 한 칸 넣어주었습니다.

## 대문자로 시작하는 lambda 변수 이름을 소문자로 시작하게 바꾸자

```shell
ag '\(([A-Z]\w*)\s?\-\>\s*\1' -l \
  | xargs gsed -i.orig -e '/\.filter/ s,(\([A-Z]\),(\L\1,; s,-> \([A-Z]\),-> \L\1,'
```

- `ag`
 - `'\(([A-Z]\w*)\s?\-\>\s*\1'`: `(Bla -> Bla` 형식의 문자열을 매칭합니다. 나눠서 볼까요.
  - `\(`: `(`
  - `([A-Z]\w*)`: 대문자로 시작하는 문자열을 매칭합니다. 그룹1입니다.
  - `\s?`: 공백 0~1자
  - `\-\>`: `->`
  - `\s*`: 공백 0자 이상
  - `\1`: 그룹1
- `gsed`: Mac OS의 `sed`에는 제약사항이 있어 GNU의 `sed`를 사용할 수 있게 만들어주는 것 같습니다.
 - `-i.orig`: 파일을 직접 수정하되 suffix가 주어졌으므로 원본 파일에 `.orig` 을 붙여 백업합니다.
 - `-e '/\.filter/ s,(\([A-Z]\),(\L\1,; s,-> \([A-Z]\),-> \L\1,'`
  - `/\.filter/`: 뭐지
  - `s,(\([A-Z]\),(\L\1,`: `s` 명령 다음에 나오는 single-byte 문자는 구분자로 취급된다고 합니다. 그러니까 `s/(\([A-Z]\)/(\L\1/`와 동일한 거죠. [참고](https://backreference.org/2010/02/20/using-different-delimiters-in-sed/)
  - `s,-> \([A-Z]\),-> \L\1,`: 뭐지

## 화살표 연산자 좌우에 스페이스를 1개 추가하자

```shell
find . -name '*.java' \
  | xargs ag '\-\>(?=\S)|(?<=\S)\-\>' -l \
  | xargs sed -i.orig -E "s,([^ ])->,\1 ->,; s,->([^ ]),-> \1,"
```

- `ag`
 - `'\-\>(?=\S)|(?<=\S)\-\>'`: `|`(or)로 구분되어 있습니다.
  - `\-\>(?=\S)`
   - `\-\>(?=\S)`: `?=`는 전방탐색을 말합니다. `\S`(공백 제외 문자)까지 매칭을 시키지만 `\S`는 소비되지 않습니다. 예를 들어 `->ABC`라면 `->A`까지 매칭 조건이지만 실제 매칭 문자열은 `->`까지만입니다.
  - `(?<=\S)\-\>`: `?<=`는 후방탐색을 말합니다. 예를 들어 `ABC->`라면 `C->`까지 매칭 조건이지만 실제 매칭 문자열은 `->`까지만입니다.
- `sed`
 - `"s,([^ ])->,\1 ->,; s,->([^ ]),-> \1,"`: 두 개의 명령이 `;`로 구분되어 있습니다.
  - `s,([^ ])->,\1 ->,`: 공백을 제외한 문자 바로 다음에 `->`가 나오면 사이에 공백을 추가합니다.
  - `s,->([^ ]),-> \1,`: `->` 바로 다음에 공백을 제외한 문자가 나오면 사이에 공백을 추가합니다.

## 프로젝트 전체에서 탭 문자를 sed로 2 spaces로 교체하자

```shell
find . -name '*.java' \
  | xargs ag '\t' -l \
  | xargs sed -E -i '' "s/[[:cntrl:]]/  /g"
```

- `find . -name '*.java'`: java 파일만 찾습니다.
- `ag '\t' -l`: Tab을 포함한 파일의 이름만 출력합니다.
- `sed`
 - `-i ''`: 제 환경에서는 `-i''`와 같이 붙여야 동작했습니다.
 -`"s/[[:cntrl:]]/  /g"`
  - `s`: 대치
  - `[[:cntrl:]]`: 제어 문자를 말합니다. Tab이 포함되겠습니다. [참고](https://www.gnu.org/software/sed/manual/sed.html#Character-Classes-and-Bracket-Expressions)
  - `  `: `  `(2 spaces)
  - `g`: 이 플래그를 주지 않으면 각 라인에서 최초로 매칭되는 부분만 대치됩니다.

## 여는 중괄호 앞에 스페이스를 1개 추가하자

```shell
ag '\)\{' -l | xargs sed -i.orig 's/){/) {/'
```

위에서 모두 나왔던 용례로 파일 내 "){"를 ") {"로 바꾸는 명령입니다.

## 마치며

앞으로 언젠간 분명 활용할 일이 있을 것 같은 예제를 가지고 공부하니 오랜만에 신이 났습니다. 막연하게 셸로 많은 것을 할 수 있지만 사용법은 복잡하겠지 하고 생각해 왔었는데 알고 나니 조금 고민하면 여기저기 써 먹을 수 있겠다는 자신감이 붙네요. 항상 좋은 글을 써 주셔서 김종립님께는 감사할 다름입니다.

명령어를 직접 제가 다니고 있는 회사 코드에 실행해 보니 컨벤션에 맞지 않는 부분이 꽤나 많이 나왔습니다. 하지만 아쉽게도 이런 식의 전역적인 코드 수정은 되도록이면 하지 않는 분위기인데, 워낙 많은 사람들이 많은 부분을 하루에도 몇 번씩 수정하다 보니 컨플릭을 해결하기가 까다로워서(귀찮아서?)로 보입니다. 나중에 한 번씩 큰 수정이 있을 시기를 노려보려고 합니다.